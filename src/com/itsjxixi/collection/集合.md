# 集合

> 集合是一个对象容器，用于存放对象。
>
> 数组的缺点是：增删操作需要进行多次交换，耗费大量时间。
>
> 集合的特点：动态大小、类型安全（指在编译时就可以检测集合元素类型，避免发生转换异常）
>

## 集合分类：

![](.\img\1.png)

![](.\img\2.png)

特点：

`Collection 接口`，存储一组 不唯一，无序 的对象

`List 接口`	存储一组不唯一，有序（索引顺序）的对象

`Set 接口	`	存储一组唯一，无序的对象

 

`Map接口`		存储一组键值对象，提供key到value的映射

--- Key  		 唯一 无序     

--- value  	不唯一 无序



## 迭代器

用于对集合遍历。ArrayList中实现内部类

> 迭代是重复反馈过程的活动,其⽬的通常是为了逼近所需⽬标或结果。每⼀次对过程的重复称为⼀次“迭代” , ⽽每⼀次迭代得到的结果会作为下⼀次迭代的初始值。 

### 创建对象:

集合对象通过调用`iterator()`方法获取对象。使用`Iterator`类型接收。加上对应泛型。

```java
Iterator<String> it = arr.iterator();
```



### 方法：

Main2

```java
•hasNext()；
    判断集合是否还有下一个元素
•next()；
    获取当前元素，指针向后移动。也代表一个迭代器一次只能执行一次，不然会出现索引越界异常。
•remove()；
    删除当前元素
```

> **集合的迭代器只能使用一次，主要是无法使指针复原。**
>
> **迭代器在迭代时，单次循环不要使用多次，会出现索引越界。**
>
> **迭代器在迭代时不要通过集合修改元素，与线程相关。**
>



## 泛型

> 在编译时起作用，但不会写入字节码文件中。



## 数据结构：

> 堆栈、队列
>
> 堆栈：先进后出
>
> 队列：先进先出



## Collection接口

> 不唯一：元素不唯一
>
> 无序：插入无序
>



### 方法：

> 接口中不存在被实现的方法，所以，所有方法都是被集合实现类实现的。
>

Main1：

```java
•add()；
	//向集合集合中添加元素
•size()；
    //返回集合中元素的个数
•contains()；
	//判断集合是否包含某个元素 
•isEmpty()；
	//判断集合是否为空 
•remove()；	
	//移除集合中元素，返回boolean类型。如果集合中不包含次元素，则删除失败  
•addAll()；
	//向⼀个集合中添加另⼀个集合 
•containsAll()；
	//判断⼀个集合中是否包含另⼀个集合
•removeAll()；
	//从⼀个集合中移除另⼀个集合
•clear()；
	//清空集合中所有元素 
•toArray()；
	//将集合转换成数组。
```







## List接口

> 不唯一：元素不唯一
>
> 有序：插入有序
>
> **List（有序）相对Collection（无序）增加了 位置/索引 相关的操作方法 **
>



### 方法：

Main3:

```java
•add([下标,]  元素);
    //添加元素，也可以在指定下表添加。
•clear(集合);
    //清空集合
•indexOf(元素);
    //返回元素在集合中的下标，如果不存在返回-1
•lastIndexOf(元素);
	//返回元素在集合中的下标（找到集合中最后⼀个相同元素），如果不存在返回-1
•remove(下标);
	//移除集合中指定下标位置上的元素 下标范围：0 ~ size-1
•set();
	//修改集合中指定下标位置上的元素 下标范围：0 ~ size-1
•get();
	//获取指定下标位置上的元素
•subList();
	//截取集合中指定下标开始到结束位置上的元素
```



### ArratList集合

本质是顺序表（数组）。

![](.\img\3.png)

> 优点：索引遍历快。
>
> 缺点：增删慢、值查询慢。
>

例子：Main4：储存多个课程



#### 实现原理：

> * 当出现add方法时，第一次添加，长度默认为10（创建时为0，为假赋值）。如果是不是，进行判断是否大于siza+1 ，大于时进行扩容操作（1.5倍）。
> * add加下标时，先判断是否需要扩容，不支持中间留空。
> * get方法，先判断下表是否在范围内。然后返回值。
>



### LinKedList集合

> 本质是链表，默认是双向链表。在某些场合下，只需要访问下一个节点，则可以使用单项链表节省空间。

![](img\4.png)

优点：增删快（但要先经过一段低效率的查询）

缺点：随机查询慢、遍历慢。



#### 方法：

Mian5:

```java
addFirst();
	// 添加在头部文件。
addLast();
	// 添加在尾部文件
removeFirst();
	// 删除头部文件
removeLast();
	// 删除尾部文件
getFirst();
	// 获取头部文件
getLast();
	// 获取尾部文件
```



**面向接口编程**

````java
List<String> list = new ArrayList<String>();
````

这样在`list`类型被更改时，下面方法都不需要被改变。

因为两个类被都继承了List接口。



Main6：定义一个集合类，存储若干个学生对象（Student（id,name,age,score）），遍历输出，再排序，再遍历输出！ 





## Collections工具类

方法：Main15:

```java
Collections.addAll(list1, 111,333,222,666,777,555);
	// 添加
Collections.sort(list1);
	// 排序
Collections.binarySearch(list1, 555);
	// 二分查找，要求有序
Collections.copy(list2, list1);
	// 复制，此方法需要目标集合有相应数据，否则异常
Collections.fill(list1, 4444);
	// 填充替换。将所有值替换为4444.
Collections.max(list1);
	// 最大值
Collections.min(list1);
	// 最小值
Collections.synchronizedList(list1);
	// 将集合转为线程安全
	// Vector线程安全的   ArrayList 线程不安全的
```





## set接口

> 唯一：元素唯一
>
> 无序：插入无序
>
> 因为插入无序所以，所有与索引有关的方法都不能使用。只能通过for-each、迭代器遍历。



### 方法：

Main7

```java
add()
    // 添加
size()
    // 元素个数
remove()
    // 删除
contains()
    // 是否包含某元素
clear()
    // 清空
isEmpty()
    // 是否为空
iterator()
    // 迭代器
```



### HashSet集合

> 采用哈希表中的顺序表结合链表。称为`葡萄藤`。
>
> **添加快、查询快、删除快**
>
> 无序，无法使用任何索引方法。
>
> 不重复：相同元素会被覆盖



> **实际是调用了HashMap**



#### 哈希表：

> 采用顺序表加链表。
>
> 先获取hash值，取余X，X为顺序表长度，需要判断在什么情况下，才能使数据均匀分开。在这里不需要判断。
>
> 取余后的值为索引，移动到对应顺序表，如果位置上有值，则连接上这个值，成为链表。
>
> X-一般使用素数。

![](E:\thinkaboutai\java-oop\src\com\itsjxixi\collection\img\5.png)

案例1：使用set存储学生的分数

```java
Main8
```



#### 去重原理：

> 比较两个对象`hash`值，值相同则判断对象相同，调用`equals`方法判断。



案例2：储存学生对象。

```java
Main9
```

> 对于属性相同的对象，却没有发生覆盖。需要重写`hashCode()、equals()`方法，在 `equals()` 方法中写出比较条件。而相同属性的学生类，由于对象的不同，所以也需要重写`hash()`方法，更改计算方式。





#### LinkedHashSet集合

> 继承了HashSet集合。
>
> 采用哈希表存储结构，同时使用链表维护次序
>
> 有序（添加顺序）
>
> 不重复（值）
>
> 方法相同。



### TreeSet集合

> 采用二叉树（红黑树）的存储结构，小于进入左子树，大于进入右子树。
>
> 优点：有序（元素）  查询速度比List快（按照内容查询）
>
> 缺点：查询速度没有 HashSet 快。
>
> 不重复、无序。
>
> **使用之前需要实现Comparable 接口用于比较对象用于排序**



案例1：储存成绩。

```java
Main10
```

案例2：储存学生信息

```java
Main11
```

> 被比较的对象内部需要实现内部比较器。才能实现比较。或者在创建集合对象时使用构造器传入外部比较器。

```java
Set <Student> stuset2 = new TreeSet<Student>(new Comparator<Student>() {
                                        @Override
                                        public int compare(Student stu1, Student stu2) {
                                            return stu1.getName().compareTo(stu2.getName());
                                        }				
});
```



案例3：

```java
每个单位要进行员工编号，编号规则为：首字母为A，后面为6位数字，按照自然数顺序依次排列，不够的补0，请为前1000名员工生成这些编号。
A000001
Main12
```





## Map接口

> Map集合是双列集合，由key和value组成。称之为键值对 
>
> 键的特点：⽆序，⽆下标，不重复。 
>
> 值的特点：⽆序，⽆下标，可重复 



### 方法：

Main13:

```java
put(K key, V value)
    // 添加 键、值
get(Object key) 
    // 根据 键 获取 值
Set<K> keySet()
    // 获取所有 键，返回值是 Set<键的类型>
Collection<V> values() 
    // 获取所有 值，返回值是 Collection<值的类型>
Set<Map.Entry<K,V>> entrySet() 
    // 获取键、值对象，getKey、getValue获取值。
boolean containsKey(Object key) 
    // 查询是否存在 键
boolean containsValue(Object value) 
    // 查询是否存在 值
V remove(Object key)
    // 删除指定 键 的 值， 返回 值
int size()
    // 元素个数
```



### 遍历方式：

Main14：



### **HashMap**集合

>   Key   无序  唯一 （Set）
>
>   Value 无序  不唯一 （Collection）
>
> 数据结构：哈希表+二叉树



### 原理

> a. 将 Key 使用哈希算法得到 hash值。
>
> b. 如果是第一次添加元素，会创建一个16长度的数组。
>
> c. 如果不是第一次，hash 值与数组长度进行运算，得到一个位置。
>
>  	1. 位置元素相同，覆盖。
> 		2. 如果是二叉树，添加入二叉树。
> 		3. 如果是链表，遍历链表。
>      		1. 相同覆盖
>      		2. 不同添加尾部。
>      		3. 当链表长度大于8，转为二叉树。
>
> d. 如果元素个数大于阈值（0.75），扩容。



### LinkedHashMap

> 有序的HashMap   速度快
>
> 唯一 有序
>
> 哈希表+链表(有序)



### **TreeMap集合**

> 有序   速度没有hash快
>
> 唯一 
>
> 自然有序
>
> 二叉树



## 综合案例

**购物车的设计** 

1. 需求分析

商品信息（名字）、商品数量（购买数量）、 添加商品（数量加一）、展示。

1. 系统设计
2. 代码实现
3. 测试



## 总结：

### 1.集合和数组的比较

> 1：数组的按索引查询效率高于集合类。
>
> 2：数组能存放基本数据类型和对象，而集合类中只能放对象。
>
> 3:   数组容量固定且无法动态改变，集合类容量动态改变。 
>
> 4：数组无法判断其中实际存有多少元素，length只告诉了array容量。
>
> 5：集合有多种实现方式和不同适用场合，不像数组仅采用顺序表方式
>
> 6：集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性调用

### 2.ArrayList和LinkedList 的联系和区别

联系：

> 都实现了List接口
>
> 有序  不唯一（可重复）

 

ArrayList

> 在内存中分配连续的空间，采用了顺序表结构，实现了长度可变的数组
>
> 优点：遍历元素和随机访问元素的效率比较高（通过索引）
>
> 缺点：添加和删除需大量移动元素效率低，按照内容查询效率低。

 

LinkedList

> 采用链表存储方式。增加了首尾相关的操作
>
> 缺点：遍历和随机访问元素效率低下
>
> 优点：插入、删除元素效率比较高（但是前提必须先以低效率查询才可。如果插入删除发生在头尾可以减少查询次数）

### 3.Collection和Collections的区别 

> Collection是Java提供的集合接口，存储一组不唯一，无序的对象。它有两个子接口List和Set。
>
> 
>
> Collections类，专门用来操作集合类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

### 4.Vector和ArrayList的联系和区别

实现原理相同，功能相同，都是长度可变的数组结构，很多情况下可以互用。

两者的主要区别如下

> Vector是早期JDK类，ArrayList是替代Vector的新类
>
> Vector线程安全（同步），ArrayList重速度轻安全，线程非安全

长度需增长时，Vector默认增长一倍，ArrayList增长50%

### 5.HashMap和Hashtable的联系和区别 

> 实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用 bri;H�1@#'

Hashtable是早期JDK提供的集合类，HashMap是新版JDK提供的集合类

Hashtable继承Dictionary类，HashMap继承AbstractMap<K,V>实现

两者都实现了Map接口 

Hashtable线程安全（速度慢），HashMap 非线程安全（速度快）

Hashtable不允许null值，HashMap允许null值（不建议）

### 6.集合比较

![](E:\thinkaboutai\java-oop\src\com\itsjxixi\collection\img\6.png)















