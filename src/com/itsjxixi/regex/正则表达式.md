# 正则表达式

又称为规则表达式。是计算机科学的一种概念，常用于检索、替换符合规则的文本。



## 符号：

普通字符：数字、字母

元符号：具有特殊含义的字符。



## 表达式：

### 字符类：

 ```java
[abc] ----   a、b 或 c（简单类） （某一位上只能是a,b,c）  
[^abc] ----   任何字符，除了 a、b 或 c（否定） 
[a-z] ----  a 到 z ，两头的字母包括在内（范围） 
[a-zA-Z] ----  a 到 z 或 A 到 Z，两头的字母包括在内（范围） 
[a-d[m-p]] ----  a 到 d 或 m 到 p：[a-dm-p]（并集） 
[a-z&&[def]] ----  d、e 或 f（交集） 
[a-z&&[^bc]] ----  a 到 z，除了 b 和 c：[ad-z]（减去） 
[a-z&&[^m-p]] ----  a 到 z，而非 m 到 p：[a-lq-z]（减去） 
 ```



### 预定义字符

```java
.   ----  任何字符（与行结束符可能匹配也可能不匹配） 
\d  ----  数字：[0-9] 
\D  ----  非数字： [^0-9] 
\s  ----  空白字符：[ \t\n\x0B\f\r] 
\S  ----  非空白字符：[^\s] 
\w  ----  单词字符：[a-zA-Z_0-9] 
\W  ----  非单词字符：[^\w] 

```



### 边界匹配器

```java
^  ---- 行的开头    
$  ---- 字符串行尾       
\b  ---- 单词边界    
\B  ---- 非单词边界 
\A ---- 输入的开头 										
\G ---- 上一个匹配的结尾 
\Z ---- 输入的结尾，仅用于最后的结束符（如果有的话） 
\z ---- 输入的结尾 
```



### 数量词

```java
X?  ---- X，一次或一次也没有   （举例演示）
X*  ---- X，零次或多次  任意次
X+  ---- X，一次或多次 
X{n} ---- X，恰好 n 次 
X{n,} ---- X，至少 n 次 
X{n,m} ---- X，至少 n 次，但是不超过 m 次
```



## 方法：

### 匹配：

```java
被判断字符串.matches(正则表达式);
```

案例：

Main1：判断是否为电话号码

Main2：判断是否为座机



### 切割：

```java
被切割的字符串.split(正则表达式);
(.)\\1+
    表示任意字符组，\1表示被捕获的第一个组（相当于第一个组的复制版），后面的数字可变，+表示一个或以上
```

Main3：按照`#`分割字符串

涉及到组的概念。



### 替换

```java
被替换的字符串.replaceAll(正则表达式);
```

Main4： 手机号屏蔽

美元符加数字也能表示捕获符。与\1在不同地方使用。



### 获取

```java
//1、将正则规则进行对象的封装
Pattern p = Pattern.compile(regex);
//2、通过正则对象获取匹配器对象
Matcher m = p.matcher(str);
//
while (m.find()) {
    //获取匹配的子序列
    System.out.println(m.group());
    System.out.println(m.start() + " : " + m.end());
}
```



Main5：获取由三个字符组成的单词 

Main6：治疗口吃：我我...我我...我要...要要要要...要要要要...学学学学...编编编编编....程程 

Main7：校验邮箱地址

Main8：前端静态爬虫







