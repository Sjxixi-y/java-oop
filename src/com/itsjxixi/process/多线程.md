# 多线程

程序：是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。  

进程：执行中的程序。是一个动态的概念。

​	特性：动态性、并发性、独立性。

线程：是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位，指运行中的程序的调度单位。

进程和线程的区别：

进程是作为资源分配的单位，线程是调度和执行的单位。



## 实现：

一、继承类`Thread`，重写`run`方法。使用`start`方法起动线程。



二、实现接口`Runnable`，重写`Run`方法。创建一个`Thread`对象，传入实现类对象为参数。



线程启动：调用父类无参，默认获取一个名字。可以通过`setName`方法改名字。



案例一：龟兔赛跑

```java
Main1
```



案例二：多人赛跑

```java
Main2
```



案例三：购票

```java
Main3
```





## 线程的生命周期

新生状态：线程被创建

就绪状态：线程完成准备工作，随时可以执行

运行状态：拿到时间片资源，处理事务

阻塞状态：出现阻塞事件，让出时间片资源。

死亡状态：线程被销毁。



## 线程控制方法

**（1）Priority --- 优先级别**

设置优先级别

```java
Main4
grtPriority();
setPriority();
```

只是提高调度的概率，没有多大的意义，操作系统的调度不会完全按照用户的设置。



**（2）join --- 强势**

使其他线程进入阻塞状态，独占时间片资源。

案例：join练习

```java
Main5
线程对象.join();
```

**join应该在start之后调用 **



**（3）sleep --- 阻塞**

案例：预备 1 2 3 发射

```java
Main6
线程对象.sleep（时间（单位 毫秒）)
```

案例：模拟时间变化

```java
Main7
```



**（4）yield --- 投降**

让当前执行的线程进入就绪状态。

案例：交替执行

```java
Main8
```



**（5）Daemon --- 守护线程**

当主线程完成时，守护线程也会结束。

**在线程启动前设置。**

案例：教程

```java
Main9
```

**在main方法线程结束后，之所以还会有一段时间后台线程执行。是main关闭的过程中会有一段很短的时间，在此期间，后台线程就会执行，直到main被彻底关闭。**





## 线程同步

> 让多行耦合高的代码都能执行，不会在没完全执行时丢失时间片资源，导致数据出现问题。



**内部锁**：Java中每个对象都有一个内部锁（也成为监视器锁），可以用于控制对象的访问。在一个线程获得对象的内部锁之后，其他线程就不能获得该对象的内部锁，直到持有锁的线程释放锁。 

**同步监视器**：是Java中的一个概念，用于实现线程同步，每次实现都需要获取一个内部锁。



（1）同步代码块

```java
synchronized (内部锁) {
    // 代码块
}
```

（2）同步方法

```java
private synchronized void 方法名() {
    // 代码块
}
```

同步方法之所以不需要内部锁，是因为他本身就是被当前对象的内部锁监控的。自然而然的获取了内部锁。



### 死锁：

> 相互等待对方释放锁。



案例：哲学家吃饭问题。































