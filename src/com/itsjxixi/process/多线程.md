# 多线程

**程序：**是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。  

**进程：** 执行中的程序。是一个动态的概念。

​	特性：动态性、并发性、独立性。

**线程：** 是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位，指运行中的程序的调度单位。

**进程和线程的区别：**

进程是作为资源分配的单位，线程是调度和执行的单位。



## 实现：

一、继承类`Thread`，重写`run`方法。使用`start`方法起动线程。



二、实现接口`Runnable`，重写`Run`方法。创建一个`Thread`对象，传入实现类对象为参数。



**要点：**

1. 实现接口的类，被创建对象后，其实是创建了一个任务，再创建类`Thread`来创建线程，执行刚刚的任务。
2. 线程启动时，调用了父类无参，会默认获有一个名字。可以通过`setName`方法或`构造方法`修改名字。
3. `mian`方法其实也是一个线程，名字`main`。



**案例一：**龟兔赛跑

Main1：

```java
public class Main1 {
    public static void main(String[] args) {
        WuGuiThread wu = new WuGuiThread();
        TuZiRunnable tu = new TuZiRunnable();
        
        Thread th1 = new Thread(tu);

        wu.start();
        th1.start();
    }
}
```



TuZiRunnable：

```java
public class TuZiRunnable implements Runnable{
    @Override
    public void run() {
        while (true) {
            System.out.println("兔子领先了==========");
        }
    }
}
```



WuGuiThread：

```java
public class WuGuiThread extends Thread{
    @Override
    public void run() {
        while (true) {
            System.out.println("乌龟领先了。。。。。");
        }
    }
}
```

src/com/itsjxixi/process/mains/main1



**案例二：**多人赛跑

Main2

```java
public class Main2 {
    public static void main(String[] args) {
        Runnable su = () -> {
            int a = 0;
            while (a++ < 10000) {
                System.out.println(Thread.currentThread().getName() + " - 领先了");
            }
        };

        Thread t1 = new Thread(su);
        Thread t2 = new Thread(su);
        Thread t3 = new Thread(su);

        t1.start();
        t2.start();
        t3.start();
    }
}
```

src/com/itsjxixi/process/main/Main2.java



**案例三：**购票

Main3

```java
public class Main3 {
    public static void main(String[] args) {
        Runnable su = () -> {
            int piao = 200;
            while (piao > -1) {
                System.out.println(Thread.currentThread().getName() + "抢到了，还剩" + piao-- + "张票");
            }
        };

        Thread t1 = new Thread(su);
        Thread t2 = new Thread(su);
        Thread t3 = new Thread(su);
        Thread t4 = new Thread(su);

        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
```

src/com/itsjxixi/process/main/Main3.java



## 简单方法

```java
setName();
	// 修改线程名，可以通过构造方法来修改。如果不修改会有一个默认名字。
getName();
	// 获取线程名
Thread.currentThread();
	// 获取当前线程对象 
```



## 线程的生命周期

**新生状态：**线程被创建。

**就绪状态：**线程完成准备工作，等待CPU调度。

**运行状态：**拿到时间片资源，处理自身事务。

**阻塞状态：**出现阻塞事件，或者被迫休眠。只能让出时间片资源。

**死亡状态：**线程被销毁。



## 线程控制方法

**（1）Priority --- 优先级别**

**设置优先级别：**

```java
grtPriority();
	// 获取优先级别
setPriority();
	// 修改优先级别
```



**案例：**

Main4

```java
public class Main4 {
    public static void main(String[] args) {
        // 获取默认优先级
        System.out.println(Thread.currentThread().getPriority());
        // 修改默认优先级
        Thread.currentThread().setPriority(10);
        System.out.println(Thread.currentThread().getPriority());
    }
}
```

src/com/itsjxixi/process/main/Main4.java

**注意：**只是提高调度的概率，没有多大的意义，操作系统的调度不会完全按照用户的设置。



**（2）join --- 等待加入**

> 使其他线程进入阻塞状态，独占时间片资源。只有线程之间具有包含关系才能有效。
>



**案例：**join练习

Main5

```java
public class Main5 {
    public static void main(String[] args) throws InterruptedException {
        Runnable ru = () -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("-------" + Thread.currentThread().getName() + "--------");
            }
        };

        for (int i = 0; i < 10; i++) {
            System.out.println("__________main___________");
            if (i == 5) {
                Thread t1 = new Thread(ru);
                Thread t2 = new Thread(ru);

                t1.start();
                t2.start();
                // 线程等待
                t1.join();
                t2.join();
            }
        }
    }
}
```

src/com/itsjxixi/process/main/Main5.java



**要点：** 

1. 线程 `t1` 与 `t2` 之间是并列关系，`join` 方法不能影响。
2.  `join`应该在 `start` 之后调用 



**（3）sleep --- 休眠（进入阻塞状态）**

> 使当前线程进入休眠状态某个时间。
>



**案例：**预备 1 2 3 发射

Main6

```java
public class Main6 {
    public static void main(String[] args) {
        System.out.print("准备");
        try {
            // 休眠
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.print('\r');
        for (int i = 1; i < 4; i++) {
            try {
                System.out.print(i);
                Thread.sleep(1000);
                System.out.print('\r');
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("发射");
    }
}
```

src/com/itsjxixi/process/main/Main6.java



**案例：**模拟时间变化

Main7

```java
public class Main7 {
    public static void main(String[] args) {

        // DateFormat sdf = new SimpleDateFormat("hh:mm:ss");

        while(true){

            Date now = new Date();
            // String strdate = sdf.format(now);

            // System.out.print(strdate);
            System.out.print(now.toLocaleString());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print('\r');
        }

    }
}
```

src/com/itsjxixi/process/main/Main7.java



**（4）yield --- 投降**

> 让当前执行的线程进入就绪状态。争抢cpu资源。
>



案例：交替执行

Main8

```java
public class Main8 {
    public static void main(String[] args) {
        Runnable ru = () -> {
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + "：" + i);
                Thread.yield();
            }
        };
        Thread t1 = new Thread(ru);
        Thread t2 = new Thread(ru);
        t1.start();
        t2.start();
    }
}
```

src/com/itsjxixi/process/main/Main8.java



**（5）Daemon --- 守护线程**

> 当主线程完成时，守护线程也会结束。



**案例：**教程

Main9

```java
public class Main9 {
    public static void main(String[] args) {
        Runnable ru = () -> {
            while (true) {
                System.out.println("A________________________________");
            }
        };
        Thread t1 = new Thread(ru);
        // 是否为后台线程，设置为 true.
        t1.setDaemon(true);
        t1.start();
        for (int i = 0; i < 10; i++) {
            System.out.println("main==================");
        }
    }
}
```

src/com/itsjxixi/process/main/Main9.java



**要点：**

1. 在main方法线程结束后，之所以还会有一段时间后台线程执行。是main关闭的过程中会有一段很短的时间，在此期间，后台线程就会执行，直到main被彻底关闭。
2. 在线程启动前设置。





## 线程同步

> 让多行耦合高的代码都能执行，不会在没完全执行时丢失时间片资源，导致数据出现安全问题。



**内部锁**：Java中每个对象都有一个内部锁（也成为监视器锁），可以用于控制对象的访问。在一个线程获得对象的内部锁之后，其他线程就不能获得该对象的内部锁，直到持有锁的线程释放锁。 

**同步监视器**：是Java中的一个概念，用于实现线程同步，每次实现都需要获取一个内部锁。



**（1）同步代码块**

```java
synchronized (内部锁) {
    // 代码块
}
```



**（2）同步方法**

```java
private synchronized void 方法名() {
    // 代码块
}
```

**注意：**同步方法之所以不需要内部锁，是因为他本身就是被当前对象的内部锁监控的。自然而然的获取了内部锁。



**案例：**在购票系统中，程序会出现很多次重复购票的情况。解决：

Main10

```java
public class Main10 {
    public static void main(String[] args) {
        ShouPiaoKou su = new ShouPiaoKou();

        Runnable ru = () -> {
            int piao = 200;
            while (piao > -1) {
                // 同步代码块
                synchronized (Main10.class) {
                    // 之所以增加判断：是为了去除最后几个的负数问题。
                    if (piao <= 0) {
                        break;
                    }
                    System.out.println(Thread.currentThread().getName() + " 抢到了，还剩" + --piao + "张票");
                }
            }
        };

        // Thread t1 = new Thread(su, "售票处A");
        // Thread t2 = new Thread(su, "售票处B");
        // Thread t3 = new Thread(su, "售票处C");
        // Thread t4 = new Thread(su, "售票处D");

        Thread t1 = new Thread(ru, "售票处A");
        Thread t2 = new Thread(ru, "售票处B");
        Thread t3 = new Thread(ru, "售票处C");
        Thread t4 = new Thread(ru, "售票处D");

        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
```



ShouPiaoKou

```
public class ShouPiaoKou implements Runnable {
    int piao = 200;
    @Override
    public void run() {
        c();
    }
    // 同步方法
    public synchronized void c() {
        while (true){
            if (piao <= 0) {
                return;
            }
            System.out.println(Thread.currentThread().getName() + " 抢到了，还剩" + --piao + "张票");
        }
    }
}
```

src/com/itsjxixi/process/mains/main10



**问题：**最后几次输出会出现负数问题。

**解决：**在进入同步监视器后，增加一个判断。

**原因：**之所以出现负数问题，是在条件还满足的情况下其余线程进入了while循环，锁外等待，最后一次执行完成，其余线程逐一进入监视器。



**案例：**多个用户从账户中取钱。

Main11

```java
public class Main11 {
    public static void main(String[] args) {
        B b =new B();
        Runnable ru = () -> {
            while (b.getBalance() > 100) {
                synchronized (B.class) {
                    if (b.getBalance() > 100) {
                        b.setBalance();
                        System.out.println(Thread.currentThread().getName() + "取走了100元， 还剩" + b.getBalance());
                    } else {
                        System.out.println(Thread.currentThread().getName() + "取钱失败， 还剩" + b.getBalance());
                    }
                }
            }
        };

        Thread f = new Thread(ru, "A");
        Thread p = new Thread(ru, "B");
        Thread c = new Thread(ru, "C");

        f.start();
        p.start();
        c.start();
    }
}
```



B

```java
public class B {
    private int balance = 1050;

    public int getBalance() {
        return balance;
    }

    public void setBalance() {
        balance -= 100;
    }
}
```

src/com/itsjxixi/process/mains/main11





### 死锁：

> 多个线程相互等待对方释放锁。



**案例：**哲学家吃饭问题。

Main12

```java
public class Main12 {
    public static void main(String[] args) throws InterruptedException {
        // A a = new A();
        // B b = new B();

        Runnable ru1 = () -> {
            synchronized (C.obj2) {
                System.out.println(Thread.currentThread().getName() + "获取到了 Obj1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (C.obj1) {
                    System.out.println(Thread.currentThread().getName() + "获取到了 Obj2");
                }
            }
        };

        Runnable ru2 = () -> {
            synchronized (C.obj1) {
                System.out.println(Thread.currentThread().getName() + "获取到了 Obj1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (C.obj2) {
                    System.out.println(Thread.currentThread().getName() + "获取到了 Obj2");
                }
            }
        };

        Thread a = new Thread(ru1);
        Thread b = new Thread(ru2);

        a.start();
        // 解决
        // Thread.sleep(1000);
        b.start();
    }
}
```

两个线程都在等待对方释放出另一个资源好让自己完成任务。



A

```java
public class A extends Thread{
    @Override
    public void run() {
        synchronized (C.obj1) {
            System.out.println("A拿到了obj1");
            synchronized (C.obj2) {
                System.out.println("A拿到了obj2");
            }
        }
    }
}
```



B

```java
public class B extends Thread {
    @Override
    public void run() {
        synchronized (C.obj2) {
            System.out.println("B拿到了obj1");
            synchronized (C.obj1) {
                System.out.println("B拿到了obj2");
            }
        }
    }
}
```



C

```java
public class C {
    public static final Object obj1 = new Object();
    public static final Object obj2 = new Object();
}
```

src/com/itsjxixi/process/mains/main12



**解决：**

src/com/itsjxixi/process/mains/main12

可以在两个线程启动之间间隔久一点时间。



## 线程通信

> 线程之间的相互通信：唤醒操作。



生产者和消费者问题

**案例：**当生产者生产完成商品，并通知消费者（通信）。

Main13

```java
public class Main13 {
    volatile static C c = new C();

    public static void main(String[] args) {
        Runnable ru1 = () -> {
            for (int i = 0; i < 10; i++) {
                if (i % 2 == 0) {
                    c.set("面包");
                } else {
                    c.set("土豆");
                }
            }
        };

        Runnable ru2 = () -> {
            for (int i = 0; i < 10; i++) {
                c.get();
            }
        };

        Thread t1 = new Thread(ru1);
        Thread t2 = new Thread(ru2);


        t1.start();
        t2.start();
    }
}
```



C

```java
public class C {
    // 产品名字
    private String name;
    // 产品是否存在
    private boolean cp = false;

    // 消费
    public synchronized void get() {
        if (!cp) {
            try {
                System.out.println("无商品，消费者等待中");
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("正在消费商品" + name);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        name = "";
        cp = false;
        this.notifyAll();
    }

    // 生产
    public synchronized void set(String name) {
        if (cp) {
            try {
                System.out.println("有商品，生产者等待中。");
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("正在生产商品" + name);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.name = name;
        cp = true;
        this.notifyAll();
    }
}
```

src/com/itsjxixi/process/mains/main13



**方法：**

```java
wait();
	// 表示线程一直在等待
notify();
	// 唤醒一个处于等待中的线程
notifyAll();
	// 唤醒同一个对象调用wait()方法的休眠线程。
```



## 线程池

**问题**：大量创建线程可能会导致内存泄露，不断创建销毁浪费系统性能。

**解决：**创建线程池。定义线程数，不会浪费过多资源。

**注意：**在线程池中的线程处于新生状态。



**创造线程池：**

一、创建实体实现类：

```java
// 线程池顶级接口
Executor
// 线程池接口
ExecutorService
```



二、线程池工具类：

```java
Executors类
```

```java
// 获取固定数量的线程池
工具类.newFixedThreadPool(int nThreads);
// 获取动态线程池
工具类.newCachedThreadPool();
// 获取单线程池
工具类.newSingleThreadExecutor()
// 通过线程池提交任务
线程池对象.submit(任务);
// 关闭线程池
线程池对象.shutdown();
```



**案例：**

Main14

```java
public class Main14 {
    public static void main(String[] args) {
        ExecutorService e = Executors.newFixedThreadPool(2);
        
        Runnable r = () -> {
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName() + "A");
            }
        };

        for (int i = 0; i < 2; i++) {
            e.submit(r);
        }

        e.shutdown();
    }
}
```

src/com/itsjxixi/process/main/Main14.java



### Callable接口

> 创建线程的第三种方式。与 Runnable  类似，创建一个任务对象。不同的是 Callable 接口有返回值类型。



**注意：**无法被线程类直接使用，需要转化为一个可用任务。

```java
FutureTask<Integer> task = new FutureTask<Integer>(callable);
```

> FutureTask：实现了 Future 接口、Runnable 接口。



**例子：**

Mian15

```java
public class Main15 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Callable<Integer> c = () -> {
            int num = 0;
            for (int i = 0; i < 100; i++) {
                num += i;
            }
            return num;
        };

        FutureTask<Integer> task = new FutureTask<>(c);

        Thread t = new Thread(task);

        t.start();
        
        System.out.println(task.get());
    }
}
```

src/com/itsjxixi/process/main/Main15.java



虽然看着繁琐，但结合线程池却很方便，使用线程池提供的方法。

```
submit()
```



**例子：**

Mian16

```java
public class Main16 {
    public static void main(String[] args) {
        ExecutorService e1 = Executors.newFixedThreadPool(1);

        Callable<Integer> c = () -> {
            int num = 0;
            for (int i = 0; i < 100; i++) {
                num += i;
            }
            System.out.println(num);
            return num;
        };

        e1.submit(c);
        
        e1.shutdown();
    }
}
```

src/com/itsjxixi/process/main/Main16.java



### Future接口

> 表示将要完成任务的结果。
>
> get() 以阻塞形式等待 Future 中的异步处理结果 

**方式：**

```java
Future<Integer> future1 = es.submit(任务）
```

> 以异步的方式执行



**例子：**两个线程分别计算1到100之间的和，然后合并输出。

Main17

```java
public class Main17 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService e1 = Executors.newFixedThreadPool(2);
        // 线程任务提交，线程开始执行
        Future<Integer> f1 = e1.submit(() -> {
            int num = 0;
            for (int i = 0; i <= 50; i++) {
                num += i;
            }
            System.out.println(num);
            return num;
        });
        // 线程任务提交，线程开始执行
        Future<Integer> f2 = e1.submit(() -> {
            int num = 0;
            for (int i = 51; i <= 100; i++) {
                num += i;
            }
            System.out.println(num);
            return num;
        });
        
        System.out.println(f1.get() + f2.get());
        e1.shutdown();
    }
}
```



### 同步与异步

**同步：**线程按照串行执行，线程之间有关联关系。

**异步：**线程按照并发执行，但需要线程之间没有关联关系。



## Lock接口

> 也是锁的一种，类似 synchronized 关键字。但比 synchronized 关键字强大。



常用方法：

```java
// 获取锁
lock();
// 释放锁
unlock;
```



### 1.重入锁

> 指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象加的锁，而其他线程不可以。

**实现类：**ReentrantLock

**主要目的：**防止死锁。



**案例：**分别向数组插入数据。

Main18

```java
public class main18 {
    static Lock lock = new ReentrantLock();

    static String[] arr = {"A", "B", "C", null, null};

    static int size = 3;

    public static void main(String[] args) throws InterruptedException {
        Runnable r1 = () -> {
            try {
                lock.lock();
                arr[size++] = "D";
            } finally {
                lock.unlock();
            }
            System.out.println(Arrays.toString(arr));
        };

        Runnable r2 = () -> {
            try {
                lock.lock();
                arr[size++] = "E";
            } finally {
                lock.unlock();
            }
            System.out.println(Arrays.toString(arr));
        };

        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r2);

        t1.start();
        t2.start();

        System.out.println(Arrays.toString(arr));
    }
}
```

src/com/itsjxixi/process/main/Main18.java



**案例：**购票

Main19

```java
public class Main19 {
    private static int a = 200;
    private static final Lock lock = new ReentrantLock();

    public static void main(String[] args) {
        Runnable r1 = () -> {
            while (true) {
                lock.lock();
                try {
                    if (a <= 0) {
                        break;
                    }
                    System.out.println(Thread.currentThread().getName() + "购买了一张票，还剩" + --a + "张票");
                } finally {
                    lock.unlock();
                }
            }
        };

        Runnable r2 = () -> {
            while (true) {
                lock.lock();
                try {
                    if (a <= 0) {
                        break;
                    }
                    System.out.println(Thread.currentThread().getName() + "购买了一张票，还剩" + --a + "张票");
                } finally {
                    lock.unlock();
                }
            }
        };

        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r2);

        t1.start();
        t2.start();
    }
}
```

src/com/itsjxixi/process/main/Main19.java



**注意：**关锁放在异常中强制执行。



## **拓展 - 其他锁：**

**独占锁：**只有一个线程能获取锁

公平锁

非公平锁

乐观锁

悲观锁



读写锁

写的同时不可以再进行写，但可以多次读。



线程安全集合

转换

```
synchronizedCollection()
synchronizedList()
synchronizedSet()
synchronizedMap()
```







